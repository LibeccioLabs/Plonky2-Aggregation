use plonky2::{
    field::types::Field64,
    hash::poseidon::PoseidonHash,
    iop::witness::{PartialWitness, WitnessWrite},
    plonk::{
        circuit_builder::CircuitBuilder,
        circuit_data::{CircuitConfig, CircuitData},
        config::GenericConfig,
        proof::ProofWithPublicInputs,
    },
};

// Degree of field extension in PGConfig.
const D: usize = 2;
type PGConfig = plonky2::plonk::config::PoseidonGoldilocksConfig;
type BaseField = <PGConfig as GenericConfig<D>>::F;

mod utilities;

mod proof_aggregation;
use proof_aggregation::{aggregate_proofs, circuit_aggregate_proofs_forward_input, deserialize_aggregated_proof_public_input};

/// Given a circuit `base_circuit`, the main funcion builds new circuits, whose
/// statement is equivalent to the verification of many instances of
/// `base_circuit`. Then, some proof instances for `base_circuit` are generated,
/// and they are used to build witnesses to generate proofs for the new circuits.
/// The verification times of those proofs are then benchmarked.
fn main() {
    const AGGREGATION_ARITY: usize = 3;
    const UP_TO_HOW_MANY_PROOFS: usize = 27;
    const BASE_CIRCUIT_INPUT_LENGTH: usize = 100;
    const N_VERIFY_REPETITIONS: usize = 100;

    let circuit_config = CircuitConfig::standard_recursion_zk_config();

    let (
        base_circuit,
        base_circuit_proof_generator
    ) = base_circuit::<BASE_CIRCUIT_INPUT_LENGTH>(circuit_config);
    
    let mut base_proofs = vec![];
    base_proofs.reserve(UP_TO_HOW_MANY_PROOFS);
    base_proofs.push(base_circuit_proof_generator(&base_circuit));

    println!("Start of the benckmark process.");
    println!("Up to {UP_TO_HOW_MANY_PROOFS} proof instances of the same circuits will be aggregated, starting from 2.");
    println!("Every aggregated proof will be verified {N_VERIFY_REPETITIONS} times, to smooth out random noise.");
    println!("Generating the proofs takes time. Please, be patient. This benchmark could last a couple of hours.");

    for n in 2..UP_TO_HOW_MANY_PROOFS {
        base_proofs.push(base_circuit_proof_generator(&base_circuit));

        let aggregated_proof_circuit = circuit_aggregate_proofs_forward_input(
            &base_circuit,
            n,
            AGGREGATION_ARITY
        );

        let aggregated_proof = aggregate_proofs(
            &base_circuit,
            {
                let mut v = Vec::new();
                v.extend_from_slice(&base_proofs[..n]);
                v
            },
            AGGREGATION_ARITY
        ).expect("proof aggregation goes wrong");

        for (idx, p_idx) in deserialize_aggregated_proof_public_input(
            &base_circuit,
            n,
            &aggregated_proof
        ).expect("deserialization of aggregated public inputs fails")
        .into_iter()
        .enumerate() {
            
            assert_eq!(
                base_proofs[idx].public_inputs,
                p_idx,
                "aggregated public inputs don't coincide with original public inputs"
            );

        }
        
        let aggregated_proof_clones: [_; N_VERIFY_REPETITIONS] = core::array::from_fn(|_| aggregated_proof.clone());

        println!("benchmarking aggregation of {n} proofs:");
            crate::time_it!{
                for proof in aggregated_proof_clones {
                    aggregated_proof_circuit.verify(proof).expect("verification of aggregated proof fails")
                };
                "It takes {:?}"
            }
    }
}

/// We don't care what the circuit actually does. We just know that this
/// function outputs a non-trivial circuit, together with a function
/// that can generate valid proofs for said circuit.
/// 
/// Also, the generic parameter determines the number of public inputs
/// of the circuit generated by this function.
fn base_circuit<const INPUT_LENGTH: usize>(
    circuit_config: CircuitConfig,
) -> (
    CircuitData<BaseField, PGConfig, D>,
    impl Fn(&CircuitData<BaseField, PGConfig, D>) -> ProofWithPublicInputs<BaseField, PGConfig, D>,
) {
    let mut builder = CircuitBuilder::<BaseField, D>::new(circuit_config);
    let input: [_; INPUT_LENGTH] = builder.add_virtual_hashes(INPUT_LENGTH).try_into().unwrap();
    let hash_out_targets: [_; INPUT_LENGTH] = core::array::from_fn(|idx| {
        builder.hash_n_to_hash_no_pad::<PoseidonHash>(input[idx].elements.into())
    });
    for h in hash_out_targets {
        builder.register_public_inputs(&h.elements);
    }

    let circuit = builder.build::<PGConfig>();

    let random_proof_generator =
        move |circuit: &CircuitData<BaseField, PGConfig, D>|
            -> ProofWithPublicInputs<BaseField, PGConfig, D> {
        let mut witness = PartialWitness::new();
        for h in input {
            let input_value: [_; plonky2::hash::hash_types::NUM_HASH_OUT_ELTS] =
                core::array::from_fn(|_| BaseField::from_canonical_i64(rand::random()));
            witness.set_target_arr(&h.elements, &input_value);
        }

            circuit.prove(witness).expect("proof generation fails")
        
    };

    (circuit, random_proof_generator)
}
